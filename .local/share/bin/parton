#!/usr/bin/env bash
#
# parton - run parallel commands in the context of a running Proton game
#

set -euo pipefail

readonly PHD="${XDG_RUNTIME_DIR:-/run/user/$UID}/parton"

# Capture host display environment before gamescope overwrites them
declare -A HOST_ENV=(
	[DISPLAY]="${DISPLAY-}"
	[WAYLAND_DISPLAY]="${WAYLAND_DISPLAY-}"
	[XDG_RUNTIME_DIR]="${XDG_RUNTIME_DIR-}"
	[XDG_CURRENT_DESKTOP]="${XDG_CURRENT_DESKTOP-}"
	[XDG_SESSION_DESKTOP]="${XDG_SESSION_DESKTOP-}"
	[XDG_SESSION_TYPE]="${XDG_SESSION_TYPE-}"
	[XDG_SESSION_CLASS]="${XDG_SESSION_CLASS-}"
	[XDG_SESSION_ID]="${XDG_SESSION_ID-}"
	[XDG_SESSION_PATH]="${XDG_SESSION_PATH-}"
	[XDG_BACKEND]="${XDG_BACKEND-}"
)

die() {
	printf '%s\n' "$*" >&2
	exit 1
}

usage() {
	cat <<-EOF
	Usage:
	  parton catch <command>
	      Wrap a Steam launch command to capture the Proton environment.
	      Use in Steam launch options: parton catch %command%

	  parton ls
	      List running games (by AppID).

	  parton run [--bypass-gamescope[=WxH]] <appid> <exe> [args...]
	      Run a Windows executable via Proton.
	      --bypass-gamescope  Run on host display in a Wine virtual desktop.
	                          Optional resolution (default: 1280x720).

	  parton exec [--bypass-gamescope] <appid> <command> [args...]
	      Run a raw command with the game's environment (no Proton wrapper).
	EOF
}

# Restore host display environment variables
restore_host_env() {
	for var in "${!HOST_ENV[@]}"; do
		if [[ -n ${HOST_ENV[$var]} ]]; then
			export "$var=${HOST_ENV[$var]}"
		else
			unset "$var"
		fi
	done
}

# Load saved environment for an appid
load_app_env() {
	local appid=$1
	local app_dir="$PHD/$appid"

	[[ -d $app_dir ]] || die "No app running with appid \"$appid\""

	# shellcheck source=/dev/null
	source "$app_dir/env"

	# Ensure WINEPREFIX is set for direct wine calls
	if [[ -z ${WINEPREFIX-} && -n ${STEAM_COMPAT_DATA_PATH-} ]]; then
		export WINEPREFIX="$STEAM_COMPAT_DATA_PATH/pfx"
	fi

	# Match the running wineserver's sync mode
	export WINEFSYNC=1
}

get_proton_exe() {
	local appid=$1
	cat "$PHD/$appid/exe"
}

get_wine64() {
	local proton_exe=$1
	local proton_dir
	proton_dir="$(dirname "$proton_exe")"
	echo "$proton_dir/files/bin/wine64"
}

cmd_init() {
	[[ $# -ge 1 ]] || die "catch requires a command"
	[[ -n ${SteamAppId-} ]] || die "SteamAppId not set (not launched from Steam?)"

	local app_dir="$PHD/$SteamAppId"
	mkdir -p "$app_dir"

	# Find proton executable in args
	printf '%s\n' "$@" | grep -m1 "/proton" >"$app_dir/exe"
	printf '%s' "$STEAM_COMPAT_DATA_PATH/pfx" >"$app_dir/pfx"
	declare -px >"$app_dir/env"

	local ec=0
	"$@" || ec=$?

	rm -r "${PHD:?}/${SteamAppId:?}"
	exit $ec
}

cmd_ls() {
	[[ -d $PHD ]] && ls -1 "$PHD"
}

cmd_run() {
	local bypass_gamescope=0
	local desktop_res="1280x720"

	while [[ $# -gt 0 ]]; do
		case $1 in
			--bypass-gamescope) bypass_gamescope=1; shift ;;
			--bypass-gamescope=*) bypass_gamescope=1; desktop_res="${1#*=}"; shift ;;
			*) break ;;
		esac
	done

	[[ $# -ge 2 ]] || die "run requires <appid> <exe>"

	local appid=$1; shift
	load_app_env "$appid"

	if [[ $bypass_gamescope -eq 1 ]]; then
		restore_host_env
		local wine64
		wine64="$(get_wine64 "$(get_proton_exe "$appid")")"
		exec "$wine64" explorer "/desktop=parton,$desktop_res" "$@"
	else
		exec "$(get_proton_exe "$appid")" run "$@"
	fi
}

cmd_exec() {
	local bypass_gamescope=0

	while [[ $# -gt 0 ]]; do
		case $1 in
			--bypass-gamescope) bypass_gamescope=1; shift ;;
			*) break ;;
		esac
	done

	[[ $# -ge 2 ]] || die "exec requires <appid> <command>"

	local appid=$1; shift
	load_app_env "$appid"

	[[ $bypass_gamescope -eq 1 ]] && restore_host_env

	exec "$@"
}

main() {
	[[ $# -ge 1 ]] || { usage; exit 1; }

	local cmd=$1; shift

	case $cmd in
		catch) cmd_init "$@" ;;
		ls)   cmd_ls ;;
		run)  cmd_run "$@" ;;
		exec) cmd_exec "$@" ;;
		-h|--help|help) usage ;;
		*) die "Unknown command: $cmd" ;;
	esac
}

main "$@"
