#!/usr/bin/env bash

set -euo pipefail

# Walker-based screen recording helper.
# - If a recording is running (gpu-screen-recorder), stop it.
# - Otherwise, show a Walker dmenu with common presets.

CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}"
USER_DIRS_FILE="$CONFIG_DIR/user-dirs.dirs"

if [[ -f "$USER_DIRS_FILE" ]]; then
  # shellcheck disable=SC1090
  . "$USER_DIRS_FILE"
fi

OUTPUT_DIR="${XDG_VIDEOS_DIR:-$HOME/Videos}"

if [[ ! -d "$OUTPUT_DIR" ]]; then
  if command -v notify-send >/dev/null 2>&1; then
    notify-send "Screen recording directory does not exist" "$OUTPUT_DIR" -u critical -t 3000
  else
    printf 'Screen recording directory does not exist: %s\n' "$OUTPUT_DIR" >&2
  fi
  exit 1
fi

require() {
  if ! command -v "$1" >/dev/null 2>&1; then
    local msg="Required command not found: $1"
    if command -v notify-send >/dev/null 2>&1; then
      notify-send "Screen recording error" "$msg" -u critical -t 5000
    fi
    printf '%s\n' "$msg" >&2
    exit 1
  fi
}

require "walker"
require "gpu-screen-recorder"

focused_monitor_info() {
  # Prints: "NAME WxH"
  require "hyprctl"
  require "jq"

  local name
  name=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true) | .name' | head -n1)
  if [[ -z "$name" || "$name" == "null" ]]; then
    return 1
  fi

  # Prefer gpu-screen-recorder's reported resolution for this monitor,
  # because it matches what gsr expects for -s.
  local size=""
  local line
  while IFS= read -r line; do
    if [[ "$line" == "$name|"* ]]; then
      size=${line#*|}
      break
    fi
  done < <(gpu-screen-recorder --list-capture-options)

  if [[ -z "$size" ]]; then
    size=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true) | "\(.width)x\(.height)"' | head -n1)
  fi
  if [[ -z "$size" || "$size" == "null" ]]; then
    return 1
  fi

  printf '%s %s\n' "$name" "$size"
}

pick_monitor() {
  local prompt="Pick screen"
  local -a items=()

  local line
  while IFS= read -r line; do
    # Monitor entries look like: HDMI-A-1|2560x1440
    if [[ "$line" != *"|"* ]]; then
      continue
    fi
    local name=${line%%|*}
    local res=${line#*|}
    items+=("$name | $res")
  done < <(gpu-screen-recorder --list-capture-options)

  if [[ ${#items[@]} -eq 0 ]]; then
    if command -v notify-send >/dev/null 2>&1; then
      notify-send "Screen recording error" "No monitors reported by gpu-screen-recorder." -u critical -t 5000
    fi
    return 1
  fi

  local selection
  selection=$(printf '%s\n' "${items[@]}" | walker --dmenu --width 360 --minheight 1 --maxheight 630 --placeholder "$prompt…") || return 1

  local name=${selection%% *}
  local res=${selection##*| }
  if [[ -z "$name" || -z "$res" ]]; then
    return 1
  fi
  printf '%s %s\n' "$name" "$res"
}

all_screens_region() {
  require "hyprctl"
  require "jq"

  hyprctl monitors -j | jq -r '
    (map(.x) | min) as $minx |
    (map(.y) | min) as $miny |
    (map(.x + .width) | max) as $maxx |
    (map(.y + .height) | max) as $maxy |
    "\($maxx-$minx)x\($maxy-$miny)+\($minx)+\($miny)"
  '
}

# Notify waybar’s screen recording indicator to refresh
toggle_screenrecording_indicator() {
  pkill -RTMIN+8 waybar 2>/dev/null || true
}

start_recording() {
  local capture_mode="$1"  # screen, screen_pick, all_screens, region, window
  local audio_mode="$2"    # none, desktop

  local filename
  filename="$OUTPUT_DIR/screenrecording-$(date +'%Y-%m-%d_%H-%M-%S').mp4"

  local audio_devices=""

  case "$audio_mode" in
  desktop)
    audio_devices="default_output"
    ;;
  none)
    audio_devices=""
    ;;
  *)
    audio_devices=""
    ;;
  esac

  local args=()
  if [[ -n "$audio_devices" ]]; then
    args+=("-a" "$audio_devices")
  fi

  local w_value
  local -a size_args=()
  local region_args=()

  case "$capture_mode" in
  screen)
    local info
    info=$(focused_monitor_info) || return 1
    w_value=${info%% *}
    size_args=(-s "${info##* }")
    ;;
  screen_pick)
    local picked
    picked=$(pick_monitor) || return 1
    w_value=${picked%% *}
    size_args=(-s "${picked##* }")
    ;;
  all_screens)
    local region
    region=$(all_screens_region) || return 1
    if [[ -z "$region" ]]; then
      if command -v notify-send >/dev/null 2>&1; then
        notify-send "Screen recording error" "Failed to compute all-screens region." -u critical -t 5000
      fi
      return 1
    fi
    w_value="region"
    region_args=(-region "$region")
    ;;
  region)
    require "slurp"
    # slurp format is compatible with gpu-screen-recorder -region
    local region
    if ! region=$(slurp -f "%wx%h+%x+%y"); then
      # Selection cancelled
      return 1
    fi
    w_value="region"
    region_args=(-region "$region")
    ;;
  window)
    require "slurp"
    local region
      if command -v hyprctl >/dev/null 2>&1; then
        require "jq"
        active_workspaces=$(hyprctl monitors -j | jq -c '[.[].activeWorkspace.id]')
        if ! region=$(hyprctl clients -j | jq --argjson active "$active_workspaces" '.[] | select((.hidden | not) and (.workspace.id as $id | $active | contains([$id]))) | "\(.at[0]),\(.at[1]) \(.size[0])x\(.size[1])"' -r | slurp -f "%wx%h+%x+%y"); then
          return 1
        fi
      else
        # Fallback to manual region selection if no supported compositor integration is found
        if ! region=$(slurp -f "%wx%h+%x+%y"); then
          return 1
        fi
      fi

    w_value="region"
    region_args=(-region "$region")
    ;;
  *)
    return 1
    ;;
  esac

  gpu-screen-recorder -w "$w_value" "${size_args[@]}" -f 60 -fallback-cpu-encoding yes "${region_args[@]}" -o "$filename" "${args[@]}" -ac aac &
  local pid=$!

  # Give gpu-screen-recorder a moment to either start or fail
  sleep 0.5
  if ! kill -0 "$pid" >/dev/null 2>&1; then
    # Recorder failed to start (e.g. no default audio device)
    if command -v notify-send >/dev/null 2>&1; then
      notify-send "Screen recording error" "gpu-screen-recorder failed to start. Check audio devices/defaults." -u critical -t 5000
    fi
    return 1
  fi

  toggle_screenrecording_indicator
}

stop_recording() {
  if ! pgrep -f "^gpu-screen-recorder" >/dev/null 2>&1; then
    return 1
  fi

  pkill -SIGINT -f "^gpu-screen-recorder" 2>/dev/null || true

  # Update the waybar indicator immediately
  toggle_screenrecording_indicator

  local count=0
  while pgrep -f "^gpu-screen-recorder" >/dev/null 2>&1 && [[ $count -lt 50 ]]; do
    sleep 0.1
    count=$((count + 1))
  done

  if pgrep -f "^gpu-screen-recorder" >/dev/null 2>&1; then
    pkill -9 -f "^gpu-screen-recorder" 2>/dev/null || true
    if command -v notify-send >/dev/null 2>&1; then
      notify-send "Screen recording error" "Recording process had to be force-killed. Video may be corrupted." -u critical -t 5000
    fi
  else
    if command -v notify-send >/dev/null 2>&1; then
      notify-send "Screen recording saved" "$OUTPUT_DIR" -t 2000
    fi
  fi
}

show_menu() {
  local prompt="Screenrecord"
  local options="Region
Screen (focused)
Screen (pick)
Window
All screens
Region with audio
Screen (focused) with audio
Screen (pick) with audio
All screens with audio
Window with audio"

  local selection
  selection=$(printf '%s\n' "$options" | walker --dmenu --width 360 --minheight 1 --maxheight 630 --placeholder "$prompt…") || return 1

  case "$selection" in
  "Region")
    printf '%s %s\n' "region" "none"
    ;;
  "Screen (focused)")
    printf '%s %s\n' "screen" "none"
    ;;
  "Screen (pick)")
    printf '%s %s\n' "screen_pick" "none"
    ;;
  "Window")
    printf '%s %s\n' "window" "none"
    ;;
  "All screens")
    printf '%s %s\n' "all_screens" "none"
    ;;
  "Region with audio")
    printf '%s %s\n' "region" "desktop"
    ;;
  "Screen (focused) with audio")
    printf '%s %s\n' "screen" "desktop"
    ;;
  "Screen (pick) with audio")
    printf '%s %s\n' "screen_pick" "desktop"
    ;;
  "All screens with audio")
    printf '%s %s\n' "all_screens" "desktop"
    ;;
  "Window with audio")
    printf '%s %s\n' "window" "desktop"
    ;;
  *)
    return 1
    ;;
  esac
}

if pgrep -f "^gpu-screen-recorder" >/dev/null 2>&1; then
  stop_recording
  exit 0
fi

# One-step menu: capture + audio in four presets
selection=$(show_menu) || exit 0

# Split into capture_mode and audio_mode
capture_mode=${selection%% *}
audio_mode=${selection##* }

start_recording "$capture_mode" "$audio_mode"
